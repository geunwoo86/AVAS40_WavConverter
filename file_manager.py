"""
=========================================================================================
ğŸ“Œ íŒŒì¼ëª…:      file_manager.py
ğŸ“Œ ì„¤ëª…:        AVAS40 WavConverter íŒŒì¼ ê´€ë¦¬ ì „ìš© ëª¨ë“ˆ
ğŸ“Œ ì‘ì„±ì:      Geunwoo Lee
ğŸ“Œ ì‘ì„±ì¼:      2025-01-15
ğŸ“Œ ë²„ì „:        1.00
=========================================================================================
"""

import os
import csv
from datetime import datetime
from intelhex import IntelHex
from utils import FileConstants, FilePermissionError, get_exe_directory
from config import app_settings

class FileManager:
    """íŒŒì¼ ê´€ë¦¬ ì „ìš© í´ë˜ìŠ¤"""
    
    def __init__(self, sound_type: str):
        self.sound_type = sound_type
        self.output_folder = self._get_output_folder()
    
    def _get_output_folder(self) -> str:
        """ì‚¬ìš´ë“œ íƒ€ì…ì— ë”°ë¥¸ ì¶œë ¥ í´ë” ê²½ë¡œ ë°˜í™˜"""
        base_path = app_settings.get_output_base_path()
        
        if self.sound_type == "Engine Sound":
            return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.ENGINE_FOLDER)
        else:  # Event Sound
            return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.EVENT_FOLDER)
    
    def ensure_output_folder_exists(self) -> str:
        """ì¶œë ¥ í´ë”ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ê³  ì—†ìœ¼ë©´ ìƒì„±"""
        try:
            os.makedirs(self.output_folder, exist_ok=True)
            
            # ì“°ê¸° ê¶Œí•œ í™•ì¸
            if not os.access(self.output_folder, os.W_OK):
                raise FilePermissionError(f"No write permission for directory: {self.output_folder}")
            
            return self.output_folder
        except OSError as e:
            raise FilePermissionError(f"Failed to create output directory: {e}")
    
    def save_bin_file(self, hex_data: IntelHex, filename: str = None) -> str:
        """BIN íŒŒì¼ ì €ì¥ (ì—”ì§„ ì‚¬ìš´ë“œìš©)"""
        if not filename:
            filename = FileConstants.ENGINE_BIN_FILE
        
        file_path = os.path.join(self.output_folder, filename)
        
        try:
            hex_data.tofile(file_path, format='bin')
            return os.path.basename(file_path)
        except Exception as e:
            raise FilePermissionError(f"Failed to save BIN file: {e}")
    
    def save_hex_file(self, hex_data: IntelHex, filename: str = None) -> str:
        """HEX íŒŒì¼ ì €ì¥ (ì´ë²¤íŠ¸ ì‚¬ìš´ë“œìš©)"""
        if not filename:
            filename = FileConstants.EVENT_HEX_FILE
        
        file_path = os.path.join(self.output_folder, filename)
        
        try:
            hex_data.write_hex_file(file_path, write_start_addr=False)
            return os.path.basename(file_path)
        except Exception as e:
            raise FilePermissionError(f"Failed to save HEX file: {e}")
    
    def save_header_file(self, hex_data: IntelHex, filename: str = None) -> str:
        """C í—¤ë” íŒŒì¼ ì €ì¥ (ì—”ì§„ ì‚¬ìš´ë“œìš©)"""
        if not filename:
            filename = FileConstants.ENGINE_HEADER_FILE
        
        file_path = os.path.join(self.output_folder, filename)
        
        try:
            self._write_header_file(hex_data, file_path)
            return os.path.basename(file_path)
        except Exception as e:
            raise FilePermissionError(f"Failed to save header file: {e}")
    
    def _write_header_file(self, hex_data: IntelHex, file_path: str):
        """C í—¤ë” íŒŒì¼ ë‚´ìš© ìƒì„± ë° ì €ì¥"""
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write("// Auto-generated header file for AVAS Engine Sound Data\n")
            f.write("// Generated by AVAS40 Sound Converter\n")
            f.write(f"// Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            f.write("#ifndef ENGINESOUND_VARIANT_H\n")
            f.write("#define ENGINESOUND_VARIANT_H\n\n")
            
            f.write("#include <stdint.h>\n\n")
            
            # HEX ë°ì´í„°ë¥¼ ë°”ì´íŠ¸ ë°°ì—´ë¡œ ë³€í™˜
            min_addr = hex_data.minaddr()
            max_addr = hex_data.maxaddr()
            total_size = max_addr - min_addr + 1
            
            f.write(f"// Total data size: {total_size} bytes\n")
            f.write(f"const uint8_t engine_sound_data[{total_size}] = {{\n")
            
            # 16ë°”ì´íŠ¸ì”© í•œ ì¤„ë¡œ ì¶œë ¥
            for i, addr in enumerate(range(min_addr, max_addr + 1)):
                if i % 16 == 0:
                    f.write("    ")
                
                f.write(f"0x{hex_data[addr]:02X}")
                
                if addr < max_addr:
                    f.write(", ")
                    
                if (i + 1) % 16 == 0 and addr < max_addr:
                    f.write("\n")
            
            f.write("\n};\n\n")
            f.write(f"#define ENGINE_SOUND_DATA_SIZE {total_size}\n\n")
            f.write("#endif // ENGINESOUND_VARIANT_H\n")
    
    def get_output_folder_path(self) -> str:
        """ì¶œë ¥ í´ë” ê²½ë¡œ ë°˜í™˜"""
        return self.output_folder

class LogManager:
    """ë¡œê·¸ ê´€ë¦¬ ì „ìš© í´ë˜ìŠ¤"""
    
    def __init__(self, sound_type: str):
        self.sound_type = sound_type
        self.file_manager = FileManager(sound_type)
        self.log_entries = []
    
    def add_log_entry(self, message: str):
        """ë¡œê·¸ ì—”íŠ¸ë¦¬ ì¶”ê°€"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.log_entries.append({
            'timestamp': timestamp,
            'message': message,
            'sound_type': self.sound_type
        })
    
    def save_log_to_csv(self, manual_save: bool = False) -> tuple:
        """ë¡œê·¸ë¥¼ CSV íŒŒì¼ë¡œ ì €ì¥"""
        try:
            # ì¶œë ¥ í´ë” í™•ì¸/ìƒì„±
            output_folder = self.file_manager.ensure_output_folder_exists()
            
            # ë¡œê·¸ íŒŒì¼ëª… ìƒì„± (YYYYMMDD_HHMMSS_log.csv)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            log_filename = f"{timestamp}_log.csv"
            log_filepath = os.path.join(output_folder, log_filename)
            
            # CSV íŒŒì¼ë¡œ ì €ì¥
            with open(log_filepath, 'w', newline='', encoding='utf-8') as csvfile:
                fieldnames = ['Timestamp', 'Sound Type', 'Message']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                
                writer.writeheader()
                for entry in self.log_entries:
                    writer.writerow({
                        'Timestamp': entry['timestamp'],
                        'Sound Type': entry['sound_type'],
                        'Message': entry['message']
                    })
            
            return log_filename, manual_save
            
        except Exception as e:
            raise FilePermissionError(f"Failed to save log file: {e}")
    
    def clear_log_entries(self):
        """ë¡œê·¸ ì—”íŠ¸ë¦¬ ì´ˆê¸°í™”"""
        self.log_entries.clear()

class OutputPathManager:
    """ì¶œë ¥ ê²½ë¡œ ê´€ë¦¬ ì „ìš© í´ë˜ìŠ¤"""
    
    @staticmethod
    def get_base_output_path() -> str:
        """ê¸°ë³¸ ì¶œë ¥ ê²½ë¡œ ë°˜í™˜"""
        return app_settings.get_output_base_path()
    
    @staticmethod
    def get_engine_output_path() -> str:
        """ì—”ì§„ ì‚¬ìš´ë“œ ì¶œë ¥ ê²½ë¡œ ë°˜í™˜"""
        base_path = OutputPathManager.get_base_output_path()
        return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.ENGINE_FOLDER)
    
    @staticmethod
    def get_event_output_path() -> str:
        """ì´ë²¤íŠ¸ ì‚¬ìš´ë“œ ì¶œë ¥ ê²½ë¡œ ë°˜í™˜"""
        base_path = OutputPathManager.get_base_output_path()
        return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.EVENT_FOLDER)
    
    @staticmethod
    def get_output_path_by_sound_type(sound_type: str) -> str:
        """ì‚¬ìš´ë“œ íƒ€ì…ì— ë”°ë¥¸ ì¶œë ¥ ê²½ë¡œ ë°˜í™˜"""
        if sound_type == "Engine Sound":
            return OutputPathManager.get_engine_output_path()
        else:  # Event Sound
            return OutputPathManager.get_event_output_path()
    
    @staticmethod
    def validate_output_path(path: str) -> bool:
        """ì¶œë ¥ ê²½ë¡œì˜ ìœ íš¨ì„± ê²€ì‚¬"""
        try:
            if not os.path.exists(path):
                os.makedirs(path, exist_ok=True)
            
            # ì“°ê¸° ê¶Œí•œ í™•ì¸
            return os.access(path, os.W_OK)
        except:
            return False
    
    @staticmethod
    def ensure_all_output_folders() -> dict:
        """ëª¨ë“  ì¶œë ¥ í´ë” ìƒì„± ë° ê²½ë¡œ ë°˜í™˜"""
        results = {}
        
        try:
            engine_path = OutputPathManager.get_engine_output_path()
            event_path = OutputPathManager.get_event_output_path()
            
            os.makedirs(engine_path, exist_ok=True)
            os.makedirs(event_path, exist_ok=True)
            
            results['engine'] = engine_path
            results['event'] = event_path
            results['success'] = True
            
        except Exception as e:
            results['success'] = False
            results['error'] = str(e)
        
        return results 