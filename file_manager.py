"""
=========================================================================================
ðŸ“Œ File:         file_manager.py
ðŸ“Œ Description:  File management module for AVAS40 Sound Convertor
ðŸ“Œ Author:       Geunwoo Lee
ðŸ“Œ Date:         2025-01-15
ðŸ“Œ Version:      1.00
=========================================================================================
ðŸ“Œ Main Features:
    - FileManager: Manages saving BIN/HEX/Header files
    - LogManager: Manages CSV log files
    - OutputPathManager: Manages output paths (static methods)
    - Separate folders for each sound type (EngineSound/EventSound)
    
ðŸ“Œ FileManager Key Methods:
    - ensure_output_folder_exists(): Create output folder and check permissions
    - save_bin_file(): Save BIN file (engine sound)
    - save_hex_file(): Save HEX file (event sound)
    - save_header_file(): Save C header file (engine sound)
    
ðŸ“Œ LogManager Key Methods:
    - add_log_entry(): Add log entry
    - save_log_to_csv(): Save log as CSV file (YYYYMMDD_HHMMSS_log.csv)
    - clear_log_entries(): Clear log entries
    
ðŸ“Œ OutputPathManager Key Methods:
    - get_engine_output_path(): Get engine sound output path
    - get_event_output_path(): Get event sound output path
    - validate_output_path(): Validate output path
    - ensure_all_output_folders(): Create all output folders
    
ðŸ“Œ Folder Structure:
    Output/
    â”œâ”€â”€ EngineSound/    (engine sound files)
    â””â”€â”€ EventSound/     (event sound files)
    
ðŸ“Œ Dependencies:
    - Standard library: os, csv, datetime
    - External library: intelhex
    - Local modules: utils, config
=========================================================================================
"""

import os
import csv
from datetime import datetime
from intelhex import IntelHex
from utils import FileConstants, FilePermissionError, get_exe_directory
from config import app_settings

class FileManager:
    """File management class"""
    
    def __init__(self, sound_type: str):
        self.sound_type = sound_type
        self.output_folder = self._get_output_folder()
    
    def _get_output_folder(self) -> str:
        """Return output folder path by sound type"""
        base_path = app_settings.get_output_base_path()
        
        if self.sound_type == "Engine Sound":
            return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.ENGINE_FOLDER)
        else:  # Event Sound
            return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.EVENT_FOLDER)
    
    def ensure_output_folder_exists(self) -> str:
        """Check if output folder exists and create if not"""
        try:
            os.makedirs(self.output_folder, exist_ok=True)
            
            # Check write permission
            if not os.access(self.output_folder, os.W_OK):
                raise FilePermissionError(f"No write permission for directory: {self.output_folder}")
            
            return self.output_folder
        except OSError as e:
            raise FilePermissionError(f"Failed to create output directory: {e}")
    
    def save_bin_file(self, hex_data: IntelHex, filename: str = None) -> str:
        """Save BIN file (for engine sound)"""
        if not filename:
            filename = FileConstants.ENGINE_BIN_FILE
        
        file_path = os.path.join(self.output_folder, filename)
        
        try:
            hex_data.tofile(file_path, format='bin')
            return os.path.basename(file_path)
        except Exception as e:
            raise FilePermissionError(f"Failed to save BIN file: {e}")
    
    def save_hex_file(self, hex_data: IntelHex, filename: str = None) -> str:
        """Save HEX file (for event sound)"""
        if not filename:
            filename = FileConstants.EVENT_HEX_FILE
        
        file_path = os.path.join(self.output_folder, filename)
        
        try:
            hex_data.write_hex_file(file_path, write_start_addr=False)
            return os.path.basename(file_path)
        except Exception as e:
            raise FilePermissionError(f"Failed to save HEX file: {e}")
    
    def save_header_file(self, hex_data: IntelHex, filename: str = None) -> str:
        """Save C header file (for engine sound)"""
        if not filename:
            filename = FileConstants.ENGINE_HEADER_FILE
        
        file_path = os.path.join(self.output_folder, filename)
        
        try:
            self._write_header_file(hex_data, file_path)
            return os.path.basename(file_path)
        except Exception as e:
            raise FilePermissionError(f"Failed to save header file: {e}")
    
    def _write_header_file(self, hex_data: IntelHex, file_path: str):
        """Generate and save C header file content"""
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write("// Auto-generated header file for AVAS Engine Sound Data\n")
            f.write("// Generated by AVAS40 Sound Generator\n")
            f.write(f"// Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            f.write("#ifndef ENGINESOUND_VARIANT_H\n")
            f.write("#define ENGINESOUND_VARIANT_H\n\n")
            
            f.write("#include <stdint.h>\n\n")
            
            # Convert HEX data to byte array
            min_addr = hex_data.minaddr()
            max_addr = hex_data.maxaddr()
            total_size = max_addr - min_addr + 1
            
            f.write(f"// Total data size: {total_size} bytes\n")
            f.write(f"const uint8_t engine_sound_data[{total_size}] = {{\n")
            
            # Output 16 bytes per line
            for i, addr in enumerate(range(min_addr, max_addr + 1)):
                if i % 16 == 0:
                    f.write("    ")
                
                f.write(f"0x{hex_data[addr]:02X}")
                
                if addr < max_addr:
                    f.write(", ")
                    
                if (i + 1) % 16 == 0 and addr < max_addr:
                    f.write("\n")
            
            f.write("\n};\n\n")
            f.write(f"#define ENGINE_SOUND_DATA_SIZE {total_size}\n\n")
            f.write("#endif // ENGINESOUND_VARIANT_H\n")
    
    def get_output_folder_path(self) -> str:
        """Return output folder path"""
        return self.output_folder

class LogManager:
    """Log management class"""
    
    def __init__(self, sound_type: str):
        self.sound_type = sound_type
        self.file_manager = FileManager(sound_type)
        self.log_entries = []
    
    def add_log_entry(self, message: str):
        """Add log entry"""
        self.log_entries.append({
            'message': message,
            'sound_type': self.sound_type
        })
    
    def save_log_to_csv(self, manual_save: bool = False) -> tuple:
        """Save log as CSV file"""
        try:
            # Check/create output folder
            output_folder = self.file_manager.ensure_output_folder_exists()
            
            # Generate log filename (YYYYMMDD_HHMMSS_SoundGenerator_log.csv)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            log_filename = f"{timestamp}_SoundGenerator_log.csv"
            log_filepath = os.path.join(output_folder, log_filename)
            
                        # Save as CSV file with UTF-8 BOM for Korean compatibility
            with open(log_filepath, 'w', newline='', encoding='utf-8-sig') as csvfile:
                fieldnames = ['Message', 'Start Address', 'Data Length']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                
                writer.writeheader()
                for entry in self.log_entries:
                    try:
                        # Parse file info from message if it contains '|' separator
                        file_name = ''
                        start_address = ''
                        data_length = ''
                        
                        # If message contains file info with '|' separator, parse it
                        if '|' in entry['message']:
                            parts = entry['message'].split('|')
                            if len(parts) >= 3:
                                # Extract file name, start address, and data length from message
                                file_name = parts[0].strip()
                                start_address = parts[1].strip()
                                data_length = parts[2].strip()
                                
                                writer.writerow({               
                                    'Message': file_name,
                                    #'File Name': file_name,
                                    'Start Address': start_address,
                                    'Data Length': data_length
                                })
                        else:                                            
                            writer.writerow({                       
                                'Message': entry['message']
                                #'File Name': '',
                                #'Start Address': '',
                                #'Data Length': ''
                            })
                    except Exception as e:
                        # If parsing fails, just write the message as is
                        writer.writerow({                       
                            'Message': entry['message']
                        })
            
            return log_filename, manual_save
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            raise FilePermissionError(f"Failed to save log file: {e}\nDetails: {error_details}")
    
    def clear_log_entries(self):
        """Clear log entries"""
        self.log_entries.clear()

class OutputPathManager:
    """Output path management class"""
    
    @staticmethod
    def get_base_output_path() -> str:
        """Return base output path"""
        return app_settings.get_output_base_path()
    
    @staticmethod
    def get_engine_output_path() -> str:
        """Return engine sound output path"""
        base_path = OutputPathManager.get_base_output_path()
        return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.ENGINE_FOLDER)
    
    @staticmethod
    def get_event_output_path() -> str:
        """Return event sound output path"""
        base_path = OutputPathManager.get_base_output_path()
        return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.EVENT_FOLDER)
    
    @staticmethod
    def get_output_path_by_sound_type(sound_type: str) -> str:
        """Return output path by sound type"""
        if sound_type == "Engine Sound":
            return OutputPathManager.get_engine_output_path()
        else:  # Event Sound
            return OutputPathManager.get_event_output_path()
    
    @staticmethod
    def validate_output_path(path: str) -> bool:
        """Validate output path"""
        try:
            if not os.path.exists(path):
                os.makedirs(path, exist_ok=True)
            
            # Check write permission
            return os.access(path, os.W_OK)
        except:
            return False
    
    @staticmethod
    def ensure_all_output_folders() -> dict:
        """Create all output folders and return paths"""
        results = {}
        
        try:
            engine_path = OutputPathManager.get_engine_output_path()
            event_path = OutputPathManager.get_event_output_path()
            
            os.makedirs(engine_path, exist_ok=True)
            os.makedirs(event_path, exist_ok=True)
            
            results['engine'] = engine_path
            results['event'] = event_path
            results['success'] = True
            
        except Exception as e:
            results['success'] = False
            results['error'] = str(e)
        
        return results 