"""
=========================================================================================
📌 파일명:      file_manager.py
📌 설명:        AVAS40 WavConverter 파일 관리 전용 모듈
📌 작성자:      Geunwoo Lee
📌 작성일:      2025-01-15
📌 버전:        1.00
=========================================================================================
"""

import os
import csv
from datetime import datetime
from intelhex import IntelHex
from utils import FileConstants, FilePermissionError, get_exe_directory
from config import app_settings

class FileManager:
    """파일 관리 전용 클래스"""
    
    def __init__(self, sound_type: str):
        self.sound_type = sound_type
        self.output_folder = self._get_output_folder()
    
    def _get_output_folder(self) -> str:
        """사운드 타입에 따른 출력 폴더 경로 반환"""
        base_path = app_settings.get_output_base_path()
        
        if self.sound_type == "Engine Sound":
            return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.ENGINE_FOLDER)
        else:  # Event Sound
            return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.EVENT_FOLDER)
    
    def ensure_output_folder_exists(self) -> str:
        """출력 폴더가 존재하는지 확인하고 없으면 생성"""
        try:
            os.makedirs(self.output_folder, exist_ok=True)
            
            # 쓰기 권한 확인
            if not os.access(self.output_folder, os.W_OK):
                raise FilePermissionError(f"No write permission for directory: {self.output_folder}")
            
            return self.output_folder
        except OSError as e:
            raise FilePermissionError(f"Failed to create output directory: {e}")
    
    def save_bin_file(self, hex_data: IntelHex, filename: str = None) -> str:
        """BIN 파일 저장 (엔진 사운드용)"""
        if not filename:
            filename = FileConstants.ENGINE_BIN_FILE
        
        file_path = os.path.join(self.output_folder, filename)
        
        try:
            hex_data.tofile(file_path, format='bin')
            return os.path.basename(file_path)
        except Exception as e:
            raise FilePermissionError(f"Failed to save BIN file: {e}")
    
    def save_hex_file(self, hex_data: IntelHex, filename: str = None) -> str:
        """HEX 파일 저장 (이벤트 사운드용)"""
        if not filename:
            filename = FileConstants.EVENT_HEX_FILE
        
        file_path = os.path.join(self.output_folder, filename)
        
        try:
            hex_data.write_hex_file(file_path, write_start_addr=False)
            return os.path.basename(file_path)
        except Exception as e:
            raise FilePermissionError(f"Failed to save HEX file: {e}")
    
    def save_header_file(self, hex_data: IntelHex, filename: str = None) -> str:
        """C 헤더 파일 저장 (엔진 사운드용)"""
        if not filename:
            filename = FileConstants.ENGINE_HEADER_FILE
        
        file_path = os.path.join(self.output_folder, filename)
        
        try:
            self._write_header_file(hex_data, file_path)
            return os.path.basename(file_path)
        except Exception as e:
            raise FilePermissionError(f"Failed to save header file: {e}")
    
    def _write_header_file(self, hex_data: IntelHex, file_path: str):
        """C 헤더 파일 내용 생성 및 저장"""
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write("// Auto-generated header file for AVAS Engine Sound Data\n")
            f.write("// Generated by AVAS40 Sound Converter\n")
            f.write(f"// Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            f.write("#ifndef ENGINESOUND_VARIANT_H\n")
            f.write("#define ENGINESOUND_VARIANT_H\n\n")
            
            f.write("#include <stdint.h>\n\n")
            
            # HEX 데이터를 바이트 배열로 변환
            min_addr = hex_data.minaddr()
            max_addr = hex_data.maxaddr()
            total_size = max_addr - min_addr + 1
            
            f.write(f"// Total data size: {total_size} bytes\n")
            f.write(f"const uint8_t engine_sound_data[{total_size}] = {{\n")
            
            # 16바이트씩 한 줄로 출력
            for i, addr in enumerate(range(min_addr, max_addr + 1)):
                if i % 16 == 0:
                    f.write("    ")
                
                f.write(f"0x{hex_data[addr]:02X}")
                
                if addr < max_addr:
                    f.write(", ")
                    
                if (i + 1) % 16 == 0 and addr < max_addr:
                    f.write("\n")
            
            f.write("\n};\n\n")
            f.write(f"#define ENGINE_SOUND_DATA_SIZE {total_size}\n\n")
            f.write("#endif // ENGINESOUND_VARIANT_H\n")
    
    def get_output_folder_path(self) -> str:
        """출력 폴더 경로 반환"""
        return self.output_folder

class LogManager:
    """로그 관리 전용 클래스"""
    
    def __init__(self, sound_type: str):
        self.sound_type = sound_type
        self.file_manager = FileManager(sound_type)
        self.log_entries = []
    
    def add_log_entry(self, message: str):
        """로그 엔트리 추가"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.log_entries.append({
            'timestamp': timestamp,
            'message': message,
            'sound_type': self.sound_type
        })
    
    def save_log_to_csv(self, manual_save: bool = False) -> tuple:
        """로그를 CSV 파일로 저장"""
        try:
            # 출력 폴더 확인/생성
            output_folder = self.file_manager.ensure_output_folder_exists()
            
            # 로그 파일명 생성 (YYYYMMDD_HHMMSS_log.csv)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            log_filename = f"{timestamp}_log.csv"
            log_filepath = os.path.join(output_folder, log_filename)
            
            # CSV 파일로 저장
            with open(log_filepath, 'w', newline='', encoding='utf-8') as csvfile:
                fieldnames = ['Timestamp', 'Sound Type', 'Message']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                
                writer.writeheader()
                for entry in self.log_entries:
                    writer.writerow({
                        'Timestamp': entry['timestamp'],
                        'Sound Type': entry['sound_type'],
                        'Message': entry['message']
                    })
            
            return log_filename, manual_save
            
        except Exception as e:
            raise FilePermissionError(f"Failed to save log file: {e}")
    
    def clear_log_entries(self):
        """로그 엔트리 초기화"""
        self.log_entries.clear()

class OutputPathManager:
    """출력 경로 관리 전용 클래스"""
    
    @staticmethod
    def get_base_output_path() -> str:
        """기본 출력 경로 반환"""
        return app_settings.get_output_base_path()
    
    @staticmethod
    def get_engine_output_path() -> str:
        """엔진 사운드 출력 경로 반환"""
        base_path = OutputPathManager.get_base_output_path()
        return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.ENGINE_FOLDER)
    
    @staticmethod
    def get_event_output_path() -> str:
        """이벤트 사운드 출력 경로 반환"""
        base_path = OutputPathManager.get_base_output_path()
        return os.path.join(base_path, FileConstants.OUTPUT_FOLDER, FileConstants.EVENT_FOLDER)
    
    @staticmethod
    def get_output_path_by_sound_type(sound_type: str) -> str:
        """사운드 타입에 따른 출력 경로 반환"""
        if sound_type == "Engine Sound":
            return OutputPathManager.get_engine_output_path()
        else:  # Event Sound
            return OutputPathManager.get_event_output_path()
    
    @staticmethod
    def validate_output_path(path: str) -> bool:
        """출력 경로의 유효성 검사"""
        try:
            if not os.path.exists(path):
                os.makedirs(path, exist_ok=True)
            
            # 쓰기 권한 확인
            return os.access(path, os.W_OK)
        except:
            return False
    
    @staticmethod
    def ensure_all_output_folders() -> dict:
        """모든 출력 폴더 생성 및 경로 반환"""
        results = {}
        
        try:
            engine_path = OutputPathManager.get_engine_output_path()
            event_path = OutputPathManager.get_event_output_path()
            
            os.makedirs(engine_path, exist_ok=True)
            os.makedirs(event_path, exist_ok=True)
            
            results['engine'] = engine_path
            results['event'] = event_path
            results['success'] = True
            
        except Exception as e:
            results['success'] = False
            results['error'] = str(e)
        
        return results 